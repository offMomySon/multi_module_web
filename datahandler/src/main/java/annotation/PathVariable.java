package annotation;


import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// todo
//  1) 첫번째 생각.
//  적절한 레벨의 추상적인 역할을 설명하는 모듈 이름인가.?
//  내가 느끼기에는 http, context 는 기능적인 관점의 네이밍, 역할은 아니고 적절한 레벨의 추상적인 역할을 설명하고 있다.
//  -> 왜 기능적인 관점이 아닐까?
//     * 역할에 집중된 단어가 아니라, 하나의 개념을 내포한 단어 이다.
//     * 개념을 내포한 단어가, 개념을 바탕으로 모듈의 맥락을 표현하게 되고, 맥락에서 어떤 역할을 수행하는지 자연스럽게 설명해준다.
//  [http] 외부의 http 응답을 송/수신 하며 관련된 처리를 관장하는 모듈
//  [context] 시스템에 필요한 요소들의 생성,관리하는 모듈.
//  .
//  하지만, [connection] 은 약간 애매하다.
//  * 개념도 애매하고
//  * 개념을 바탕으로 모듈의 맥락을 표현하지 못한다.
//  * 맥락을 설명하지 못하기 때문에 어떤 역할을 수행하는지 설명하지 못한다.
//  -> 하지만 어떤 역할을 가지는것은 인지가 된다. [ 역할. - method 매칭, 값 반환 처리를 관장하는 역할. ]
//  -> 맥락을 정의하고 싶으나 적절한것이 떠오르지 않는다.
//  -> 맥락을 가질만한 모듈이 아닌가?
//
//  2) 두번째 생각.
//   * 멕릭의 방향성이 존재하려면 어떤 개념이 나와야할까?
//     (1)맥락의 구체성과,
//     (2)능동적인 역할을 수행하는 개념이 패키지의 이름으로 표현되어야한다.
//
//  * 정의한 규칙을 바탕으로 pacakge 이름을 점검해보자.
//
//  * [resource] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한 단어.
//     * '자원'이라는 개념을 내포하였다.
//   (2) 개념을 바탕으로 모듈의 맥락을 표현해야한다.
//     * '자원' 이라는 개념으로 패키지가 무엇을하는지 구체적인 맥락이 표현되지 않는다.
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * 맥락이 표현되지 않기 때문에 역할이 모호해진다.
//     -> '자원' 에 관련된 어떤행위 라는 모호한 역할이 표현된다.
//
//  * [connection] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한단어.
//     * '연결' 이라는 개념을 내포하였다.
//   (2) 개념을 바탕으로 모듈의 맥학을 표현해야한다.
//     * '연결' 을 수행한다. - 맥락이 추상적이다.
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * '연결'을 수행한다. - 맥락이 추상적이기 때문에 역할 또한 추상적이다.
//
//  * [web] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한단어.
//     * 'web' 이라는 개념을 내포하였다. - 모호하다.

//  * [core] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한 단어.
//     * 'core' 이라는 개념을 내포하였다.
//   (2) 개념을 바탕으로 맥락을 표현해야한다.
//     * 'core' -> 맥락이 무엇인지 알 수 없다.
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * 맥락이 무엇인지 알 수 없기 때문에 역할이 무엇인지 알 수 없다.
//
//   * [dataHandle]
//   (0) 역할에 치우친 단어인가?
//     * yes.
//   (1) 하나의 개념을 내포한 단어.
//     * 데이터를 다루는 개념.
//   (2) 개념을 바탕으로 맥락을 표현해야한다.
//     * 맥락이 모호하다.
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * 데이터를 다루는 역할.
//
//     * 패키지 내부에서 표현되는 역할
//        * data 를 핸들링하는 역할.
//          * input data 에 적절한 변환을 수행한다.
//          * input 을 적절한 method 에 위임한다.
//          * 핸들링할 method 를 등록한다.
//          * output datat 에 적절한 변환을 처리한다.
//
//  ---- 적절하다고 생각되는 패키지 -----
//
//  * [context] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한 단어.
//     * '맥락' 이라는 개념을 내포하였다.
//     -> 단순한 개념이지만, 일반적으로 context 는 시스템을 유지를 위한 자원, 정보 관리의 개념을 내포한다.
//   (2) 개념을 바탕으로 모듈의 맥락을 표현해야한다.
//     * '맥락' 이란 개념을 바탕으로 '시스템을 유지를 위한 자원, 정보 관리'
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * '시스템을 유지를 위한 자원, 정보 관리' -> 자원,정보관리, 등록 을 수행한다.
//
//  * [http] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한 단어.
//     * 'http' 이라는 개념을 내포하였다.
//     *  server-client 통신을 수행하기 위해 네트워크를 통해 일정한 text 의 포멧으로 통신하는 프로토콜
//   (2) 개념을 바탕으로 맥락을 표현해야한다.
//     * 'http' -> http 프로토콜을 이용하여 client 연결에 관련된 처리.
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * http 프로토콜을 이용하여 client 연결, 파싱, 실행, 전송 을 처리한다.
//
//  * [engine] 가 적절한 패키지인가?
//   (0) 역할에 치우친 단어인가?
//     * none.
//   (1) 하나의 개념을 내포한 단어.
//     * 'engine' 라이브러리, 프레임워크등을 수행하는 코어라는 개념을 내포하였다.(아마도?)
//   (2) 개념을 바탕으로 맥락을 표현해야한다.
//     * 'engine' -> 라이브러리, 프레임워크등을 실제로 수행하는 맥락.
//   (3) 맥락을 바탕으로 역할을 표현해야한다.
//     * 라이브러리, 프레임워크등을 실제로 수행하는 역할.
//
//
//
//  * context 와 dataHandler 를 왜 별개의 모듈로 분리해야할까?
//  * 별개의 맥락이기 때문에 분리해야한다.
//
//  ----------------------------------
//  [Hierachy]
//  http, connection, context
//  web.
//  ----------------------------------

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface PathVariable {
    String value() default "";

    boolean required() default true;
}
